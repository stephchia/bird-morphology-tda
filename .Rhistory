mutate(group = factor(group)) %>%
setNames(c("x1","x2","y1","y2","z1","z2","w1","w2","idx","size","group"))
}
# set axes limits
lim_pc1 <- range(data_modern$pc1)
lim_pc2 <- range(data_modern$pc2)
p <- plot_gap_history(data_now, mya, segment_data, df_gaps, lim_pc1, lim_pc2, THRES_PERSIST, color)
return(list(df_gaps = df_gaps, plot = p))
}
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
# ---------------------------------------
# Wrapper that calls summary + plotting
# ---------------------------------------
plot_gap_history_print_summary <- function(dataset, mya = 0, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = FALSE) {
path_base <- file.path("data", dataset)
# get hole information
df_gaps <- get_gap_summary(path_base, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE)$df_gaps
# import data
tda <- readRDS(file.path(path_base, paste0("tda_", mya, "mya.rds")))
data_modern <- read.csv(file.path(path_base, "trait_0mya.csv"))
data_now <- read.csv(file.path(path_base, paste0("trait_", mya, "mya.csv")))
## prepare data for the scatter hole plot (top right plot)\
idx_mya <- df_gaps$idx[df_gaps$mya == mya] # index of gap appearing in x Mya
print(idx_mya)
# create data frame of all gap coordinates with columns indication gap id and size
if (length(idx_mya) > 0) {
segment_data <- bind_rows(lapply(seq_along(idx_mya), function(i) {
coords <- get_gap_coordinates(tda)[as.numeric(sub(".*_", "", idx_mya[i]))]
as.data.frame(coords[[1]]) %>%
mutate(idx = idx_mya[i], size = NA)
})) %>%
left_join(df_gaps %>% select(idx, group), by = "idx") %>%
mutate(group = factor(group)) %>%
setNames(c("x1","x2","y1","y2","z1","z2","w1","w2","idx","size","group"))
}
# set axes limits
lim_pc1 <- range(data_modern$pc1)
lim_pc2 <- range(data_modern$pc2)
p <- plot_gap_history(data_now, mya, segment_data, df_gaps, lim_pc1, lim_pc2, THRES_PERSIST, color)
return(list(df_gaps = df_gaps, plot = p))
}
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
# ----------------------------------------------------
# Gap plotting
# ----------------------------------------------------
# Generates 3-panel visualization of gap distribution across time
plot_gap_history <- function(trait_data, mya, df_segments, gap_df,
lim_pc1, lim_pc2, THRES_PERSIST, color = FALSE) {
expand <- c(0.06, 0.06)
gap_df <- arrange(gap_df, desc(group)) # adjust the plotting order (which points are on top of others)
p_trait <- ggplot(trait_data, aes(x = pc1, y = pc2)) +
geom_point(alpha = 0.4, size = 2, stroke = 0, color = "gray60") +
if (!is.na(df_segments)) geom_segment(df_segments,
mapping = aes(x = x1, xend = x2, y = y1, yend = y2, group = group, color = group),
linewidth = 1, lineend = "round") +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_continuous(limits = lim_pc2, expand = expand) +
theme_classic() +
theme(panel.grid = element_blank(),
axis.ticks.length = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_text(margin = margin(r = -16), size = 10),
axis.title = element_blank(),
legend.position = "none",
plot.margin = margin(0,0,0,0))
p_x <- ggplot(gap_df, aes(x = pc1, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.y = element_line(linewidth = 0.5),
axis.ticks.y = element_line(linewidth = 0.5),
axis.ticks.length.y = unit(-0.1, "cm"),
axis.text.y = element_text(margin = margin(r = -16), hjust = 0, size = 10),
axis.text.x = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
p_y <- ggplot(gap_df, aes(x = pc2, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc2, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
coord_flip() +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.x = element_line(linewidth = 0.5),
axis.ticks.x = element_line(linewidth =0.5),
axis.ticks.length.x = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
# set up color palettes
if (color) {
palette <- c("#cc4949","#435bab","#999999","#3a8fbd","#8a542c","#edba4c","#fa9b6b",
"#eba7b8","#9bd8fa","#d1ab92","#dde38f","#e07e2d","#ccb9ed","#dddddd")
} else {
set.seed(123)
palette <- randomcoloR::distinctColorPalette(length(unique(gap_df$group)))
}
current_color <- rev(palette[gap_df$group[which(gap_df$mya == mya)]])
p_trait <- p_trait + scale_color_manual(values = current_color)
p_x <- p_x + scale_colour_manual(values = palette)
p_y <- p_y + scale_colour_manual(values = palette)
p <- plot_grid(p_y, p_trait, NULL, p_x,
rel_widths = c(1, 2.5, 2.5), rel_heights = c(1, 1, 1), ncol = 2,
align = "hv", axis = "tblr")
return(p)
}
# ---------------------------------------
# Wrapper that calls summary + plotting
# ---------------------------------------
plot_gap_history_print_summary <- function(dataset, mya = 0, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = FALSE) {
path_base <- file.path("data", dataset)
# get hole information
df_gaps <- get_gap_summary(path_base, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE)$df_gaps
# import data
tda <- readRDS(file.path(path_base, paste0("tda_", mya, "mya.rds")))
data_modern <- read.csv(file.path(path_base, "trait_0mya.csv"))
data_now <- read.csv(file.path(path_base, paste0("trait_", mya, "mya.csv")))
## prepare data for the scatter hole plot (top right plot)\
idx_mya <- df_gaps$idx[df_gaps$mya == mya] # index of gap appearing in x Mya
print(idx_mya)
# create data frame of all gap coordinates with columns indication gap id and size
if (length(idx_mya) > 0) {
segment_data <- bind_rows(lapply(seq_along(idx_mya), function(i) {
coords <- get_gap_coordinates(tda)[as.numeric(sub(".*_", "", idx_mya[i]))]
as.data.frame(coords[[1]]) %>%
mutate(idx = idx_mya[i], size = NA)
})) %>%
left_join(df_gaps %>% select(idx, group), by = "idx") %>%
mutate(group = factor(group)) %>%
setNames(c("x1","x2","y1","y2","z1","z2","w1","w2","idx","size","group"))
} else {
segment_data <- NA
}
# set axes limits
lim_pc1 <- range(data_modern$pc1)
lim_pc2 <- range(data_modern$pc2)
p <- plot_gap_history(data_now, mya, segment_data, df_gaps, lim_pc1, lim_pc2, THRES_PERSIST, color)
return(list(df_gaps = df_gaps, plot = p))
}
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
# ----------------------------------------------------
# Gap plotting
# ----------------------------------------------------
# Generates 3-panel visualization of gap distribution across time
plot_gap_history <- function(trait_data, mya, df_segments, gap_df,
lim_pc1, lim_pc2, THRES_PERSIST, color = FALSE) {
expand <- c(0.06, 0.06)
gap_df <- arrange(gap_df, desc(group)) # adjust the plotting order (which points are on top of others)
p_trait <- ggplot(trait_data, aes(x = pc1, y = pc2)) +
geom_point(alpha = 0.4, size = 2, stroke = 0, color = "gray60") +
if (!is.na(df_segments)) { geom_segment(df_segments,
mapping = aes(x = x1, xend = x2, y = y1, yend = y2, group = group, color = group),
linewidth = 1, lineend = "round") +
}
# ----------------------------------------------------
# Gap plotting
# ----------------------------------------------------
# Generates 3-panel visualization of gap distribution across time
plot_gap_history <- function(trait_data, mya, df_segments, gap_df,
lim_pc1, lim_pc2, THRES_PERSIST, color = FALSE) {
expand <- c(0.06, 0.06)
gap_df <- arrange(gap_df, desc(group)) # adjust the plotting order (which points are on top of others)
p_trait <- ggplot(trait_data, aes(x = pc1, y = pc2)) +
geom_point(alpha = 0.4, size = 2, stroke = 0, color = "gray60") +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_continuous(limits = lim_pc2, expand = expand) +
theme_classic() +
theme(panel.grid = element_blank(),
axis.ticks.length = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_text(margin = margin(r = -16), size = 10),
axis.title = element_blank(),
legend.position = "none",
plot.margin = margin(0,0,0,0))
if (!is.na(df_segments)) {
p_trait <- p_trait +
geom_segment(df_segments,
mapping = aes(x = x1, xend = x2, y = y1, yend = y2, group = group, color = group),
linewidth = 1, lineend = "round")
}
p_x <- ggplot(gap_df, aes(x = pc1, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.y = element_line(linewidth = 0.5),
axis.ticks.y = element_line(linewidth = 0.5),
axis.ticks.length.y = unit(-0.1, "cm"),
axis.text.y = element_text(margin = margin(r = -16), hjust = 0, size = 10),
axis.text.x = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
p_y <- ggplot(gap_df, aes(x = pc2, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc2, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
coord_flip() +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.x = element_line(linewidth = 0.5),
axis.ticks.x = element_line(linewidth =0.5),
axis.ticks.length.x = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
# set up color palettes
if (color) {
palette <- c("#cc4949","#435bab","#999999","#3a8fbd","#8a542c","#edba4c","#fa9b6b",
"#eba7b8","#9bd8fa","#d1ab92","#dde38f","#e07e2d","#ccb9ed","#dddddd")
} else {
set.seed(123)
palette <- randomcoloR::distinctColorPalette(length(unique(gap_df$group)))
}
current_color <- rev(palette[gap_df$group[which(gap_df$mya == mya)]])
p_trait <- p_trait + scale_color_manual(values = current_color)
p_x <- p_x + scale_colour_manual(values = palette)
p_y <- p_y + scale_colour_manual(values = palette)
p <- plot_grid(p_y, p_trait, NULL, p_x,
rel_widths = c(1, 2.5, 2.5), rel_heights = c(1, 1, 1), ncol = 2,
align = "hv", axis = "tblr")
return(p)
}
# ---------------------------------------
# Wrapper that calls summary + plotting
# ---------------------------------------
plot_gap_history_print_summary <- function(dataset, mya = 0, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = FALSE) {
path_base <- file.path("data", dataset)
# get hole information
df_gaps <- get_gap_summary(path_base, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE)$df_gaps
# import data
tda <- readRDS(file.path(path_base, paste0("tda_", mya, "mya.rds")))
data_modern <- read.csv(file.path(path_base, "trait_0mya.csv"))
data_now <- read.csv(file.path(path_base, paste0("trait_", mya, "mya.csv")))
## prepare data for the scatter hole plot (top right plot)\
idx_mya <- df_gaps$idx[df_gaps$mya == mya] # index of gap appearing in x Mya
print(idx_mya)
# create data frame of all gap coordinates with columns indication gap id and size
if (length(idx_mya) > 0) {
segment_data <- bind_rows(lapply(seq_along(idx_mya), function(i) {
coords <- get_gap_coordinates(tda)[as.numeric(sub(".*_", "", idx_mya[i]))]
as.data.frame(coords[[1]]) %>%
mutate(idx = idx_mya[i], size = NA)
})) %>%
left_join(df_gaps %>% select(idx, group), by = "idx") %>%
mutate(group = factor(group)) %>%
setNames(c("x1","x2","y1","y2","z1","z2","w1","w2","idx","size","group"))
} else {
segment_data <- NA
}
# set axes limits
lim_pc1 <- range(data_modern$pc1)
lim_pc2 <- range(data_modern$pc2)
p <- plot_gap_history(data_now, mya, segment_data, df_gaps, lim_pc1, lim_pc2, THRES_PERSIST, color)
return(list(df_gaps = df_gaps, plot = p))
}
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
MYA <- 7
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
# ----------------------------------------------------
# Gap plotting
# ----------------------------------------------------
# Generates 3-panel visualization of gap distribution across time
plot_gap_history <- function(trait_data, mya, df_segments, gap_df,
lim_pc1, lim_pc2, THRES_PERSIST, color = FALSE) {
expand <- c(0.06, 0.06)
gap_df <- arrange(gap_df, desc(group)) # adjust the plotting order (which points are on top of others)
p_trait <- ggplot(trait_data, aes(x = pc1, y = pc2)) +
geom_point(alpha = 0.4, size = 2, stroke = 0, color = "gray60") +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_continuous(limits = lim_pc2, expand = expand) +
theme_classic() +
theme(panel.grid = element_blank(),
axis.ticks.length = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_text(margin = margin(r = -16), size = 10),
axis.title = element_blank(),
legend.position = "none",
plot.margin = margin(0,0,0,0))
if (df_segments) {
p_trait <- p_trait +
geom_segment(df_segments,
mapping = aes(x = x1, xend = x2, y = y1, yend = y2, group = group, color = group),
linewidth = 1, lineend = "round")
}
p_x <- ggplot(gap_df, aes(x = pc1, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.y = element_line(linewidth = 0.5),
axis.ticks.y = element_line(linewidth = 0.5),
axis.ticks.length.y = unit(-0.1, "cm"),
axis.text.y = element_text(margin = margin(r = -16), hjust = 0, size = 10),
axis.text.x = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
p_y <- ggplot(gap_df, aes(x = pc2, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc2, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
coord_flip() +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.x = element_line(linewidth = 0.5),
axis.ticks.x = element_line(linewidth =0.5),
axis.ticks.length.x = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
# set up color palettes
if (color) {
palette <- c("#cc4949","#435bab","#999999","#3a8fbd","#8a542c","#edba4c","#fa9b6b",
"#eba7b8","#9bd8fa","#d1ab92","#dde38f","#e07e2d","#ccb9ed","#dddddd")
} else {
set.seed(123)
palette <- randomcoloR::distinctColorPalette(length(unique(gap_df$group)))
}
current_color <- rev(palette[gap_df$group[which(gap_df$mya == mya)]])
p_trait <- p_trait + scale_color_manual(values = current_color)
p_x <- p_x + scale_colour_manual(values = palette)
p_y <- p_y + scale_colour_manual(values = palette)
p <- plot_grid(p_y, p_trait, NULL, p_x,
rel_widths = c(1, 2.5, 2.5), rel_heights = c(1, 1, 1), ncol = 2,
align = "hv", axis = "tblr")
return(p)
}
# ---------------------------------------
# Wrapper that calls summary + plotting
# ---------------------------------------
plot_gap_history_print_summary <- function(dataset, mya = 0, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = FALSE) {
path_base <- file.path("data", dataset)
# get hole information
df_gaps <- get_gap_summary(path_base, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE)$df_gaps
# import data
tda <- readRDS(file.path(path_base, paste0("tda_", mya, "mya.rds")))
data_modern <- read.csv(file.path(path_base, "trait_0mya.csv"))
data_now <- read.csv(file.path(path_base, paste0("trait_", mya, "mya.csv")))
## prepare data for the scatter hole plot (top right plot)\
idx_mya <- df_gaps$idx[df_gaps$mya == mya] # index of gap appearing in x Mya
# create data frame of all gap coordinates with columns indication gap id and size
if (length(idx_mya) > 0) {
segment_data <- bind_rows(lapply(seq_along(idx_mya), function(i) {
coords <- get_gap_coordinates(tda)[as.numeric(sub(".*_", "", idx_mya[i]))]
as.data.frame(coords[[1]]) %>%
mutate(idx = idx_mya[i], size = NA)
})) %>%
left_join(df_gaps %>% select(idx, group), by = "idx") %>%
mutate(group = factor(group)) %>%
setNames(c("x1","x2","y1","y2","z1","z2","w1","w2","idx","size","group"))
} else {
segment_data <- NULL
}
# set axes limits
lim_pc1 <- range(data_modern$pc1)
lim_pc2 <- range(data_modern$pc2)
p <- plot_gap_history(data_now, mya, segment_data, df_gaps, lim_pc1, lim_pc2, THRES_PERSIST, color)
return(list(df_gaps = df_gaps, plot = p))
}
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
# ----------------------------------------------------
# Gap plotting
# ----------------------------------------------------
# Generates 3-panel visualization of gap distribution across time
plot_gap_history <- function(trait_data, mya, df_segments, gap_df,
lim_pc1, lim_pc2, THRES_PERSIST, color = FALSE) {
expand <- c(0.06, 0.06)
gap_df <- arrange(gap_df, desc(group)) # adjust the plotting order (which points are on top of others)
p_trait <- ggplot(trait_data, aes(x = pc1, y = pc2)) +
geom_point(alpha = 0.4, size = 2, stroke = 0, color = "gray60") +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_continuous(limits = lim_pc2, expand = expand) +
theme_classic() +
theme(panel.grid = element_blank(),
axis.ticks.length = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_text(margin = margin(r = -16), size = 10),
axis.title = element_blank(),
legend.position = "none",
plot.margin = margin(0,0,0,0))
if (!is.null(df_segments)) {
p_trait <- p_trait +
geom_segment(df_segments,
mapping = aes(x = x1, xend = x2, y = y1, yend = y2, group = group, color = group),
linewidth = 1, lineend = "round")
}
p_x <- ggplot(gap_df, aes(x = pc1, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc1, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.y = element_line(linewidth = 0.5),
axis.ticks.y = element_line(linewidth = 0.5),
axis.ticks.length.y = unit(-0.1, "cm"),
axis.text.y = element_text(margin = margin(r = -16), hjust = 0, size = 10),
axis.text.x = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
p_y <- ggplot(gap_df, aes(x = pc2, y = mya, size = size, color = group,
stroke = 3 / (1 - THRES_PERSIST) * (persistence - THRES_PERSIST) + 1.5)) +
geom_point(shape = 1) +
scale_size(range = c(1, 4)) +
scale_x_continuous(limits = lim_pc2, expand = expand) +
scale_y_reverse(limits = c(10, 0), expand = expand, breaks = c(10, 5, 0)) +
coord_flip() +
theme_minimal() +
theme(panel.grid = element_blank(),
axis.title = element_blank(),
axis.line.x = element_line(linewidth = 0.5),
axis.ticks.x = element_line(linewidth =0.5),
axis.ticks.length.x = unit(-0.1, "cm"),
axis.text.x = element_text(margin = margin(t = -12), size = 10),
axis.text.y = element_blank(),
legend.position = "none",
plot.margin = margin(0, 0, 0, 0))
# set up color palettes
if (color) {
palette <- c("#cc4949","#435bab","#999999","#3a8fbd","#8a542c","#edba4c","#fa9b6b",
"#eba7b8","#9bd8fa","#d1ab92","#dde38f","#e07e2d","#ccb9ed","#dddddd")
} else {
set.seed(123)
palette <- randomcoloR::distinctColorPalette(length(unique(gap_df$group)))
}
current_color <- rev(palette[gap_df$group[which(gap_df$mya == mya)]])
p_trait <- p_trait + scale_color_manual(values = current_color)
p_x <- p_x + scale_colour_manual(values = palette)
p_y <- p_y + scale_colour_manual(values = palette)
p <- plot_grid(p_y, p_trait, NULL, p_x,
rel_widths = c(1, 2.5, 2.5), rel_heights = c(1, 1, 1), ncol = 2,
align = "hv", axis = "tblr")
return(p)
}
# ---------------------------------------
# Wrapper that calls summary + plotting
# ---------------------------------------
plot_gap_history_print_summary <- function(dataset, mya = 0, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = FALSE) {
path_base <- file.path("data", dataset)
# get hole information
df_gaps <- get_gap_summary(path_base, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE)$df_gaps
# import data
tda <- readRDS(file.path(path_base, paste0("tda_", mya, "mya.rds")))
data_modern <- read.csv(file.path(path_base, "trait_0mya.csv"))
data_now <- read.csv(file.path(path_base, paste0("trait_", mya, "mya.csv")))
## prepare data for the scatter hole plot (top right plot)\
idx_mya <- df_gaps$idx[df_gaps$mya == mya] # index of gap appearing in x Mya
# create data frame of all gap coordinates with columns indication gap id and size
if (length(idx_mya) > 0) {
segment_data <- bind_rows(lapply(seq_along(idx_mya), function(i) {
coords <- get_gap_coordinates(tda)[as.numeric(sub(".*_", "", idx_mya[i]))]
as.data.frame(coords[[1]]) %>%
mutate(idx = idx_mya[i], size = NA)
})) %>%
left_join(df_gaps %>% select(idx, group), by = "idx") %>%
mutate(group = factor(group)) %>%
setNames(c("x1","x2","y1","y2","z1","z2","w1","w2","idx","size","group"))
} else {
segment_data <- NULL
}
# set axes limits
lim_pc1 <- range(data_modern$pc1)
lim_pc2 <- range(data_modern$pc2)
p <- plot_gap_history(data_now, mya, segment_data, df_gaps, lim_pc1, lim_pc2, THRES_PERSIST, color)
return(list(df_gaps = df_gaps, plot = p))
}
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
MYA <- 8
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
ggsave(paste0("output/temp/gap_history_", MYA, "mya.pdf"), width = 10, height = 5)
MYA <- 9
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
ggsave(paste0("output/temp/gap_history_", MYA, "mya.pdf"), width = 10, height = 5)
MYA <- 10
# plots gap history and print gap summary for empirical dataset
plot_gap_history_print_summary("empirical", MYA, MAX_MYA, THRES_PERSIST, THRES_DIST, THRES_SIZE, color = TRUE)
ggsave(paste0("output/temp/gap_history_", MYA, "mya.pdf"), width = 10, height = 5)
